log相关的文件共分以下几部分：

一、基础支撑类

	1. diag_list.c & diag_list.h
		提供最基本的链表操作，维护三个链表，正在发送列表、待发送链表和待释放链表
        (1) 正在发送链表包含两个指针，头指针和尾指针，用于发送完成后，把该链表挂接到待释放链表的头部，从尾指针快速链接到待释放链表，头指针作为新的待释放链表
		(2) 待发送链表包含两个指针，头指针和尾指针，由于待打印log是有序的，需要按照时间顺序打印，所以从头指针处取log发送，从尾指针处插入新的待发送log
		(3) 待释放链表只有一个头指针，由于待释放链表是无序的，每打印完一条log，把该log插入到待释放链表头部
		(4) 待发送链表用来挂载还未发送完成的log，待释放链表用来挂载已经发送完成，但未释放的log
		(5) 所有的链表操作都在 diag_send_port.c 中完成，包括链表的插入、删除、获取操作
		(6) diag_mem.c 中会设置部分链表成员的值，用于控制log使用的内存
		(7) 该文件中的函数不会做线程隔离，所有的线程隔离操作在 diag_mem.c 和 diag_send_port.c 中完成
	
	2. diag_mem.c & diag_mem.h
		log的内存管理，提供内存的申请释放，以及流量控制，通过封装外部内存接口实现
		(1) 内存申请时，在指定的大小基础上，会加上 diag_list_t 结构体的大小
		(2) 内存申请返回内存地址时，会把实际申请到的地址加上 diag_list_t 结构体的大小，即返回 (addr + sizeof(diag_list_t))
		(3) 内存释放时，传入的地址必须是通过log的内存申请接口返回的地址，接口内部会做计算，获取外部内存释放接口需要的地址
		(4) 内存申请时，可以根据外部内存接口的实现，选择是否记录内存申请的文件名和行号，通过宏 DIAG_MALLOC_RECORD_FILE_LINE 控制
		(5) 内存申请时，会记录申请的内存大小到链表结构体中，然后加到全局变量，并自增占用内存节点的个数，内存释放时，从链表结构体中获取内存块大小，
			从全局变量中减去这块大小，同时自减内存节点个数，通过对这两个全部变量的限制，完成对log申请的内存大小和占用的内存节点个数进行限制，实现log的流量控制
	
	3. diag_format.c & diag_format.h
		对动态log的格式化处理，动态log包含普通动态log和物理层指定变参个数的动态log
		(1) 普通动态log实现了标准的格式化字符串操作，支持所有格式化的符号，包含长整型 "%ll", 浮点的 "%e %E %g %G"
		(2) 这里的动态log的格式化，只把参数填入到buffer中，对于 "%s"，把实际的字符串填入到buffer中，并word对齐，其余的格式化类型，都把参数原封不动的填入buffer中
		(3) 物理层指定变参个数的动态log只支持32位的数值变参传入，即 "%c, %d, %u, %lu" 等，"%llu, %f" 等64位数值不支持，"%s" 的字符串地址也传入工具侧也无意义

二、硬件相关类

	1. diag_transmit_port.h
		移植层需要实现的发送接口，必须实现的函数已经在该文件中声明
		(1) void diag_port_send_init(void);
            发送的初始化，包含硬件的初始化，如果使用线程发送log，还需要初始化线程
		(2) void diag_port_send_log(void *log_str, uint32_t length);
            log的发送接口，上层调用该接口把打包好的log数据发送出去
		(3) void diag_port_send_log_directly(void *log_str, uint32_t length);
            log的直接发送接口，调用该接口会直接在接口内把数据发送出去，一般用于死机内存导出
		(4) uint32_t diag_port_recv_after_dump(uint8_t *rcv_buf, uint32_t max_len);
            uart数据接收，该函数主要用在死机后的内存导出时接收命令

	2. diag_transmit_port.c
		实现log的输出线程以及硬件配置，xy2100 使用DMA和UART实现的接口层
		(1) 发送接口的参数为要发送数据的地址和长度，该接口屏蔽发送层和上层数据打包之间的耦合，让log的头结构对发送层不可见
		(2) 发送接口传入的地址必须是通过log专用的内存申请接口得到的内存地址，否则可能会发生内存越界
		(3) 发送接口内部会对传入的地址向前偏移，得到 diag_list_t 结构，并在该结构内填入要发送的长度，然后把结构插入待发送链表，判断全局标志，如果可以设置DMA，
			会在该接口内直接设置
		(4) DMA 中断，每次DMA中断认为一次DMA传输发送完成，把已发送链表插入到待释放链表，并清空已发送链表，置位全局变量，表示当前可以设置DMA，然后发送任务通知
		(5) log线程中，等待任务通知，等到后会判断DMA是否空闲，空闲的话，从有效链表中取出部分成员（取出一个还是去除多个成员，取决于是否使用DMA的list模式，由宏
            DIAG_TRANSMIT_IN_DMA_LIST_MODE 控制），若DMA空闲则设置DMA，然后判断待释放链表是否有需要释放的成员，如果有则释放，然后继续等待任务通知
        (6) 根据宏 DIAG_TRANSMIT_WITH_DMA 和 DIAG_TRANSMIT_IN_DMA_LIST_MODE，可以选择不同的port，是否使用DMA以及使用DMA的普通模式还是list模式

	3. diag_transmit_port2.c
		实现log的输出线程以及硬件配置，STM32F103 使用USART2实现的接口层，用于 xy2100 FPGA 不足时的调试
		(1) 发送接口的参数为要发送数据的地址和长度，使用该接口屏蔽发送层和上层数据打包之间的耦合，让log的头结构对发送层不可见
		(2) 发送接口传入的地址必须是通过log专用的内存申请接口得到的内存地址，否则可能会发生内存越界
		(3) 发送接口内部会对传入的地址向前偏移，得到 diag_list_t 结构，并在该结构内填入要发送的长度，然后把结构插入待发送链表，发送任务通知，通知log线程做实际硬件发送
		(4) log线程中，等待任务通知，等到后，循环获取待发送链表，依次取出链表头节点，发送数据，发完后移出待发送链表，释放内存，发送下一个，直到待发送链表为空，继续等待任务通知

三、结构体打包类
	
	1. diag_packet.c & diag_packet.h
		包含log的公共结构体 ItemHeader_t 的填充以及CRC计算函数
		(1) 公共结构体中有 sequence number 和 tick count 成员，原来这两个成员是在发送前填充然后计算CRC，现在统一在填充头结构时填充这两个成员
	
	2. diag_filter.c & diag_filter.h
		log打印的过滤器，控制log的输出，不满足条件则丢弃log
		(1) 全局的控制条件，控制发送的初始化以及所有log的输出
		(2) 每个打印接口都有单独的控制条件，用以单独控制每一类log
	
	3. diag_item_struct.h & diag_item_types.h
		log相关的头结构以及类型定义
	
	4. diag_msg_type.h
		协议栈原语相关的结构体对应关系，以及接收命令相关的枚举

四、打印类
	
	1. diag_phy_print.c
		物理层的打印，固定函数参数个数，不做格式化处理，减少执行时间，这就要求传参能是32位的参数，不支持 "%s %ll %f %e %E %g %G" 的处理
		(1) 由于不作格式化处理，这样变参只支持32位的数值参数传入，不支持 "%llu, %f" 等64位传参，而 "%s" 这样的地址参数则无意义
		(2) 变参的个数作为一个参数传入函数中，这样只需要一个函数，就可以实现任意多个变参的传入，无需每个参数个数的函数都需要一个单独的函数

	2. diag_platform_print.c
		平台级别的打印，支持静态log以及动态log，平台和协议栈都会使用
		(1) 格式化字符串时，先申请指定大小的内存（该指定大小可以通过宏 DIAG_ONE_LOG_MAX_SIZE_BYTE 配置），然后把格式化后的字符串填入申请的内存
		(2) 格式化完成后，判断实际占用的字符串大小是否达到阈值（阈值由宏 DIAG_LOG_THREAD_SIZE_BYTE 配置），如果没有，则重新申请一块适当大小的内存，
			复制数据到新申请的内存中，释放原来的内存
	
	3. diag_ps_print.c
		包含协议栈的信令打印、原语打印，以及 wireshark 数据包的打印
		(1) 协议栈信令log打印，NAS, RRC, Asn1Ber 信令都是纯数据码流，通过同一函数实现，通过参数区分不同信令
		(2) 协议栈的原语log打印，原语的内存申请在协议栈中完成，协议栈也填充好了大部分数据，协议栈申请时，会预留出log的头结构的空间
		(3) 协议栈的原语log打印，由于原语中存在指针，需要把指针指向的内容发送给pc侧，所以原语不能发送原始的数据码流
		(4) wireshark 的log打印，wireshark数据包也是数据码流，但为了和信令有所区分，单独实现为一个函数
	
	4. diag_print.h
		物理层、平台、协议栈的log打印接口的声明都在该头文件中

五、宏开关以及配置类

	1. diag_options.h & diag_config.h
		配置整个log的功能配置，默认配置都在 diag_options.h 中，但是默认配置不足以支持log运行，需要在 diag_config.h 中配置好必要条件
		(1) 通用函数的配置，内存申请释放、进出临界区、断言、内存拷贝等外部依赖接口，都通过宏的方式替换，方便移植到新的平台以及使用自定义接口
		(2) log 一些全局功能的配置，比如可以配置log最大使用内存的大小，是否使能crc校验等

六、对外头文件

	1. xy_log.h
		该头文件包含对外的所有接口，其他模块使用log时，仅包含该文件即可
		(1) 该头文件内包含外部需要使用到的log内部头文件，外部仅需要包含该文件即可
		(2) 函数名称的宏定义，使用宏名替换实际函数名，使外部不感知log内部变化

七、内存导出及命令处理

	1. diag_cmd_send.c & diag_cmd_send.h
        该文件内包含内存导出接口以及命令发送接口
		(1) 内存导出，通过log的格式，配合log工具，把内存导出到文件，一般用于死机时导出内存定位分析
        (2) 命令发送，发送包含两种方式，普通发送和直接发送，普通发送在系统正常运行时调用，直接发送一般在死机后调用
    
    2. diag_recv_msg.c & diag_recv_msg.h
        该文件用于实现log的接收处理，已经封装好接口，对外提供数据写入buffer和buffer处理的接口
    
    3. diag_recv_handler.c
        该文件实现接收命令的具体处理，以及断言时，dump接口的实现
