/*****************************************************************************************************************************
 * @brief   对CP核操作的相关接口
 * @brief   API for CP core operation
 *****************************************************************************************************************************/
#pragma once
#include "hw_types.h"

/*等待boo_CP成功的时长，超时后将会触发断言*/
#define WAIT_CP_BOOT_MS  (30*1000)  //ms


/*模组形态监控CP核启动的全局看门狗时长，一旦CP核正常启动，CP核后台会自行喂狗；否则会触发看门狗复位*/
#define CP_WATCHDOG_TIME    (2*60)   //sec


/*****************************************************************************************************************************
* @brief   严禁在中断中调用！OPENCPU产品，芯片上电默认不启动CP核，由AP核用户根据需要调用该API实现动态加载CP，并等到CP核OS开始调度才解阻塞
* @param   wait_ms  等待CP核加载的超时时长，参看宏值WAIT_CP_BOOT_MS
* @note    1、未开启CONFIG_DYN_LOAD_SELECT，耗时约20ms。开启CONFIG_DYN_LOAD_SELECT，耗时约28ms左右。
*          2、在第一条的基础上，未开启BAN_WRITE_FLASH时，耗时约280ms到300ms。
* @return  bool值。若CP核加载运行期间出异常，将会造成AP握手状态机异常，需客户容错。
* @warning 对于表计类等功耗极致要求的产品，单AP核的时钟主频可调为低频，当动态加载CP核后，必须切换为PLL高频，进而对部分外设会产生影响，需要在Hw_Init_By_LoadCP中重新初始化
****************************************************************************************************************************/
bool Boot_CP(uint32_t wait_ms);


/*****************************************************************************************************************************
* @brief   只能在CP核进入深睡流程(上报"+NPSMR:1,1"后)或检查到CP核异常时才能调用，类似强行给CP核断电，下次上电后必会attach。
* @param   wait_ms  等待CP核自行停止运行的超时时长.值为0表示由AP核直接给CP核下电，类似强行给CP核下电;设为正值,如30秒，内部会通知CP核执行软件的软关机流程，若超时未完成，再强行停CP核
* @note    当入参为0时，耗时约255us
* @note    为了保证CP核出厂NV能够在深睡时写回FLASH，建议客户在CP核进入深睡后，即AP核收到"+NPSMR:1,1"后再调用该接口，或者调用Send_Cfun(5)接口让CP核本地软关机。
* @attention 此时非易变NV中小区信息等仍有效，下次boot_CP后会快速小区驻留。若用户想维持CP核的3GPP和云状态，可通过Send_Rai()来加速进入PSM。
* @warning 该接口执行完毕，AP核仍然维持36.8M主频，直至下次深睡唤醒后才恢复AP单核的13M；而Stop_CP2接口则可以在接口内部强行切换为AP单核主频6.5M。
* 
****************************************************************************************************************************/
int Stop_CP(uint32_t wait_ms);


/*****************************************************************************************************************************
* @brief   只能在CP核进入深睡流程(上报"+NPSMR:1,1"后)或检查到CP核异常时才能调用，类似强行给CP核断电，下次上电后必会attach。
* @param   wait_ms  等待CP核自行停止运行的超时时长.值为0表示由AP核直接给CP核下电，类似强行给CP核下电;设为正值,如30秒，内部会通知CP核执行软件的软关机流程，若超时未完成，再强行停CP核
* @param   reset_ap_freq  指示是否在接口内部恢复AP单核主频13M，通常用于电压等异常处理时，以防止主频过高造成电容储电耗费过快。
* @note    当入参为0时，耗时约255us
* @note    为了保证CP核出厂NV能够在深睡时写回FLASH，建议客户在CP核进入深睡后，即AP核收到"+NPSMR:1,1"后再调用该接口。
* @attention 此时非易变NV中小区信息等仍有效，下次boot_CP后会快速小区驻留。若用户想维持CP核的3GPP和云状态，可通过Send_Rai()来加速进入PSM。
* @warning 该接口为扩展接口，以支持是否动态恢复AP单核主频。
* 
****************************************************************************************************************************/
int Stop_CP2(uint32_t wait_ms,uint8_t reset_ap_freq);


/*****************************************************************************************************************************
* @brief   用户执行完远程通信后调用，调用该接口触发RAI,以加快释放链接进入idle和PSM态，节省功耗。下次boot_CP()后，会执行恢复流程，PS与云状态机皆保持有效。
* @return  bool值，目前未使用
* @warning 调用该接口时需要确保终端已接收完下行数据报文，否则会因为下行数据报文的到来又触发进入链接态，造成功耗的额外浪费！！！
* @attention 调用该接口，将触发3GPP正常进入PSM态，为了尽量维持TAU不超时，建议TAU时长设置超过数据发送周期时长和云UPDATE时长。
* @warning  若需要维持CP核深睡期间3GPP和云状态机有效，需设置宏KEEP_CP_ALIVE为1，以设置RTC定时器(如PSM/TAU/eDRX/UPDATE等)准时唤醒，。
*****************************************************************************************************************************/
int Send_Rai(void);



/*****************************************************************************************************************************
* @brief   供用户执行3GPP开关机动作。通常供用户在执行完远程通信后调用Send_Cfun(5)，以加快进入深睡。下次boot_CP()后，会快速小区驻留并执行attach。
* @param   val  CFUN=1正常开机；CFUN=0正常软关机；CFUN=5本地软关机，不与基站通信，仅保存当前小区信息等
* @return  bool值，目前未使用
* @attention 调用该接口执行CFUN=5动作，将触发CP快速进入本地软关机，下次上电后小区等信息有效，可以快速驻留小区。
* @warning  若用户不想CP核自唤醒执行云UPDATE等周期动作，需设置宏KEEP_CP_ALIVE为0.
*****************************************************************************************************************************/
int Send_Cfun(int val);


/*****************************************************************************************************************************
* @brief   查询CP核是否已启动。调用Boot_CP后为true；调用Stop_CP后为false。
****************************************************************************************************************************/
/*****************************************************************************************************************************
* @brief   Check whether the CP core is alive
****************************************************************************************************************************/
bool CP_Is_Alive(void);



/*****************************************************************************************************************************
* @brief  AP核执行CP核的复位重启，耗时约30ms。
****************************************************************************************************************************/
void xy_CP_Reboot();





