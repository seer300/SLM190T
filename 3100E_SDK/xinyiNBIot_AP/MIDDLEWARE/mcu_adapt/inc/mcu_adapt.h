/*****************************************************************************************
该头文件是为了简化部分外设HAL接口而提取的外设适配接口，类似ST的LL库接口，以满足表计类客户的极低功耗和更小内存占用的需求。
****************************************************************************************/

#pragma once

#include <stdint.h>
#include "xinyi2100.h"
#include "xy_system.h"
#include "prcm.h"
#include "system.h"
#include "nvic.h"
#include "gpio.h"
#include "lptimer.h"
#include "timer.h"
#include "i2c.h"
#include "lcdc.h"
#include "csp.h"
#include "spi.h"
#include "uart.h"
#include "driver_utils.h"

//=====================================================================================
//================================gpio=================================================
//=====================================================================================
#define MCU_GPI_NUM (8)       //8个GPI引脚
#define MCU_GPIO_NUM (56)     //56个GPIO引脚
#define MCU_GPIOWKP_NUM  (3)  //3个WKP引脚

/**
 * @brief WKP1-3中断管理结构体
 */
typedef struct
{
    uint8_t trg_mode;  //1：触发模式为双边沿。0：触发模式为非双边沿
    pFunType_void irq;
} GPIOWkp_Irq_t;

/**
 * @brief GPI0-7中断管理结构体
 */
typedef struct
{
    uint8_t trg_mode;  //1：触发模式为双边沿。0：触发模式为非双边沿
    pFunType_void irq;
} GPI_Irq_t;

/**
 * @brief WKUP_EN引脚配置结构体
 * @note WKUP_EN是模拟引脚，不具备GPIO特性，只能作为芯片唤醒或RESET引脚使用
 */
typedef struct
{
	PIN_PullSet_Type pull;		        //WKUP_EN引脚的上下拉状态
	Polarity_Type wkup_polarity;		//WKUP_EN引脚的唤醒电平：高电平、低电平
	Trigger_Type wkup_edge;			    //WKUP_EN引脚的唤醒边沿：上升沿、下降沿、双边沿
	WakeupEn_Func_Type mode;			//WKUP_EN引脚的模式选择：单唤醒、单复位、唤醒复位
	WakeupEn_Wakeup_Pulse wakeup_time;  //WKUP_EN引脚的唤醒脉宽档位选择
	WakeupEn_Reset_Pluse reset_time;    //WKUP_EN引脚的复位脉宽档位选择
    pFunType_void irq;                  //WKUP_EN引脚的中断回调函数注册
} WakeupEn_InitTypeDef;

/*****************************************************************************************************
 * @brief GPIO编号
 * @warning 1200/1200S/2100S三颗芯片PIN脚有差异，具体信息请查阅对应的芯片手册
 ****************************************************************************************************/
typedef enum{
    MCU_WKP3 = -3,  //AGPI2
    MCU_WKP2 = -2,  //AGPI1
    MCU_WKP1 = -1,  //AGPI0
    MCU_GPIO0 = 0,
	MCU_GPIO1,  MCU_GPIO2,  MCU_GPIO3,  MCU_GPIO4,  MCU_GPIO5,  MCU_GPIO6,  MCU_GPIO7,  MCU_GPIO8,  MCU_GPIO9,  MCU_GPIO10,
	MCU_GPIO11, MCU_GPIO12, MCU_GPIO13, MCU_GPIO14, MCU_GPIO15, MCU_GPIO16, MCU_GPIO17, MCU_GPIO18, MCU_GPIO19, MCU_GPIO20,
	MCU_GPIO21, MCU_GPIO22, MCU_GPIO23, MCU_GPIO24, MCU_GPIO25, MCU_GPIO26, MCU_GPIO27, MCU_GPIO28, MCU_GPIO29, MCU_GPIO30,
	MCU_GPIO31, MCU_GPIO32, MCU_GPIO33, MCU_GPIO34, MCU_GPIO35, MCU_GPIO36, MCU_GPIO37, MCU_GPIO38, MCU_GPIO39, MCU_GPIO40,
	MCU_GPIO41, MCU_GPIO42, MCU_GPIO43, MCU_GPIO44, MCU_GPIO45, MCU_GPIO46, MCU_GPIO47, MCU_GPIO48, MCU_GPIO49, MCU_GPIO50,
	MCU_GPIO51, MCU_GPIO52, MCU_GPIO53, MCU_GPIO54, MCU_GPIO55, MCU_GPIO56, MCU_GPIO57, MCU_GPIO58, MCU_GPIO59, MCU_GPIO60,
	MCU_GPIO61, MCU_GPIO62, MCU_GPIO63
} MCU_GPIO_PinTypeDef;

/*****************************************************************************************************
 * @brief GPIO、GPI、WKP的唤醒中断模式枚举
 * 
 ****************************************************************************************************/
typedef enum
{
    MCU_GPIO_INT_BOTH,    /*双边沿中断模式*/
    MCU_GPIO_INT_RISING,  /*上升沿中断模式*/
    MCU_GPIO_INT_FALLING, /*下降沿中断模式*/
} MCU_GPIO_Int_ModeTypedef;

/*****************************************************************************************************
* @brief  设置IO驱动能力。接口耗时：16.7us。
* @param  num：GPIO端口号，可选MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @param  drvstrength：drvstrength对于不同的VDDIO参考电压代表不同的GPIO驱动能力，具体如下。
  一、当VDDIO参考电压为3V时，drvstrength有如下含义：
    0：GPIO驱动能力约为7mA    1：GPIO驱动能力约为14mA
    2：GPIO驱动能力约为21mA   3：GPIO驱动能力约为28mA
  二、当VDDIO参考电压为1.8V时，drvstrength有如下含义：
    0：GPIO驱动能力约为2mA    1：GPIO驱动能力约为5mA
    2：GPIO驱动能力约为8mA   3：GPIO驱动能力约为10mA 
* @return  0：成功。 -1：失败，非法参数
*****************************************************************************************************/
int8_t McuGpioDrvStrengthSet(MCU_GPIO_PinTypeDef num, uint8_t drvstrength);

/*****************************************************************************************************
* @brief  设置IO模式。接口耗时：num为MCU_GPIO_WKP耗时35.6us，num为MCU_GPIO耗时42.2us
* @param  num：GPIO端口号，可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @param  mode：
  0x00：推挽输出；    0x01：开漏输出
  0x11：数字浮空输入；0x12：内部上拉输入；0x13：内部下拉输入
  0x21: 浮空；       0x22：内部上拉；    0x23：内部下拉    0x24：高阻态
* @return  0：成功。 -1：失败，非法参数
* @note：WKPx不支持mode为0x01，WKPx上拉在1.4v左右为正确现象，WKPx输出高为3.0V左右
*****************************************************************************************************/
int8_t McuGpioModeSet(MCU_GPIO_PinTypeDef num, uint8_t mode);

/*****************************************************************************************************
* @brief  读GPIO电平。接口耗时：num为MCU_GPIO_WKP耗时22.9us，num为MCU_GPIO耗时16us
* @param  num：GPIO端口号，可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @return  1：高电平  0：低电平  -1：无效
*****************************************************************************************************/
int8_t McuGpioRead(MCU_GPIO_PinTypeDef num);

/*****************************************************************************************************
* @brief  写GPIO电平。接口耗时：num为MCU_GPIO_WKP耗时11.7us，MCU_GPIO耗时10.1us
* @param  num：GPIO端口号，可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @param  value：1：高电平  0：低电平
* @return  0：有效 -1：无效
*****************************************************************************************************/
int8_t McuGpioWrite(MCU_GPIO_PinTypeDef num, uint8_t value);

/*****************************************************************************************************
* @brief  翻转GPIO电平。接口耗时：入参num为MCU_GPIO_WKP耗时11.7us，MCU_GPIO耗时10.1us
* @param  num：GPIO端口号可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @note   被翻转的GPIO必须配置为输出模式
* @return  0：有效 -1：无效
*****************************************************************************************************/
int8_t McuGpioToggle(MCU_GPIO_PinTypeDef num);

/*****************************************************************************************************
* @brief  GPIO中断使能。接口耗时：num为MCU_GPIO_WKP耗时10.9us，MCU_GPIO耗时9.6us
* @param  num：GPIO端口号，可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @return  0：有效 -1：无效
* @note：
* MCU_WKP1-3 对应中断回调函数为 AGPI_Wakeup_Callback
* MCU_GPIO0-7 对应中断回调函数为 GPI_Wakeup_Callback
* MCU_GPIO8-63 对应中断服务函数为 McuGpio_IrqHandler
*****************************************************************************************************/
int8_t McuGpioIrqEn(MCU_GPIO_PinTypeDef num);

/*****************************************************************************************************
* @brief  GPIO中断禁能。接口耗时：num为MCU_GPIO_WKP耗时63.4us，MCU_GPIO耗时10.3s
* @param  num：GPIO端口号，可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @return  0：有效 -1：无效
*****************************************************************************************************/
int8_t McuGpioIrqDis(MCU_GPIO_PinTypeDef num);

/*****************************************************************************************************
* @brief  GPIO中断处理函数注册。接口耗时：num为MCU_GPIO_WKP耗时40.4us，MCU_GPIO耗时39.8us
* @param  num：GPIO端口号，可选MCU_WKP1-3，MCU_GPIO0-63，详情参考 @ref MCU_GPIO_PinTypeDef
* @param  p_fun：中断回调函数
* @param  mode: 中断触发模式，0：上升沿或下降沿触发 1：上升沿触发 2：下降沿触发 
* @return  0：有效 -1：无效
*****************************************************************************************************/
int8_t McuGpioIrqReg(MCU_GPIO_PinTypeDef num, pFunType_void p_fun, MCU_GPIO_Int_ModeTypedef mode);

/**
 * @brief 用户初始化WKUP_EN为单唤醒引脚、单复位引脚、复位唤醒引脚中的一个功能
 * @param wakeup_en_init 详情参考 @ref WakeupEn_InitTypeDef
 * @note 唤醒时序如下：
 * 	     (1)若 wkup_polarity 配为 POLARITY_HIGH ：
 *          当 wkup_edge 配为 FALLING ，则引脚触发唤醒的时序为：收到上升沿，外部持续高电平时长不少于 wakeup_time ，收到下降沿触发唤醒
 * 			当 wkup_edge 配为 RISING ， 则引脚触发唤醒的时序为：收到上升沿触发唤醒
 * 			当 wkup_edge 配为 BOTH ，   则引脚触发唤醒的时序为：收到上升沿第一次唤醒，外部持续高电平时长不少于 wakeup_time后收到下降沿第二次唤醒
 * 		 (2)若 wkup_polarity 配为 POLARITY_LOW ：
 *          当 wkup_edge 配为 FALLING ，则引脚触发唤醒的时序为：收到下降沿触发唤醒
 * 			当 wkup_edge 配为 RISING ， 则引脚触发唤醒的时序为：收到下降沿，外部持续低电平时长不少于 wakeup_time ，收到上升沿触发唤醒
 * 			当 wkup_edge 配为 BOTH ，   则引脚触发唤醒的时序为：收到下降沿第一次唤醒，外部持续低电平时长不少于 wakeup_time后收到上升沿第二次唤醒
 * @note 以上配置以WKUP_EN引脚的单唤醒功能为例，对于WKUP_EN引脚的单复位功能、复位唤醒功能，推荐用户使用如下配置：
 *       配置一： pull 配为 PIN_PULLDOWN ， wkup_polarity 配为 POLARITY_HIGH ， wkup_edge 配为 FALLING，时序为引脚收到上升沿时开始计时，当收到下降沿时，高电平持续时间大于wakeup_time小于reset_time时触发唤醒，大于reset_time时则触发复位
 *       配置二： pull 配为 PIN_PULLUP ， wkup_polarity 配为 POLARITY_LOW ， wkup_edge 配为 RISING，时序为引脚收到下降沿时开始计时，当收到上升沿时，高电平持续时间大于wakeup_time小于reset_time时触发唤醒，大于reset_time时则触发复位
 */
void WakeupEn_Init(WakeupEn_InitTypeDef *WkupEn_Pin);

//=====================================================================================
//================================uart=================================================
//=====================================================================================
/***********************************UART注意点*****************************************
    num等于0、1对应LPUART、UART2，发送时停止位固定为2bit，接收时停止位兼容1、1.5、2bit
    num等于2、3对应CSP2、CSP3发送接收时的停止位可配1或2bit
**************************************************************************************/

typedef struct 
{
    uint8_t rx_buff;
    pFunType_u8 rx_irq;    //接收完成中断回调函数指针
    pFunType_void tx_irq;  //发送完成中断回调函数指针
}mcu_uart_t;

/************************************************************************************
* @brief  带引脚配置的串口设置. 接口耗时：num为0耗时1084.7us，num为1耗时751.8us，num为2耗时1158.9us，num为3耗时1159.2us
* @param  num 串口号，可选0-3，0:LPUART、1:UART、2:CSP2_UART、3:CSP3_UART
* @param  baud_rate 波特率
* @param  data_len  6：6位数据位  7：7位数据位  8：8位数据位    
* @param  stop_bit  1：1位停止位  2：2位停止位 （该参数在num为0、1时只能配2）
* @param  check_bit 0：无校验位   1：奇校验位 2：偶校验位
* @param  tx_pin 发送引脚的gpio号（0-63）（该参数在num为0时只能配3）
* @param  rx_pin 接收引脚的gpio号（0-63）（该参数在num为0时只能配4）
* @return  0：成功。 -1：失败，非法参数
************************************************************************************/
int8_t McuUartSet(uint8_t num, uint32_t baud_rate, uint8_t data_len, uint8_t stop_bit, uint8_t check_bit, uint8_t tx_pin, uint8_t rx_pin);

/************************************************************************************
* @brief  串口接收使能。接口耗时：num为0耗时7.5us，num为1耗时5.3us，num为2耗时5.6us，num为3耗时5.6us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @return NA
************************************************************************************/
void McuUartRxEn(uint8_t num);

/************************************************************************************
* @brief  串口接收禁能。接口耗时：num为0耗时7.5us，num为1耗时5.3us，num为2耗时5.6us，num为3耗时5.6us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @return NA
************************************************************************************/
void McuUartRxDis(uint8_t num);

/************************************************************************************
* @brief  串口发送使能。接口耗时：num为0耗时8.3us，num为1耗时6.1us，num为2耗时5.6us，num为3耗时5.6us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @return NA
************************************************************************************/
void McuUartTxEn(uint8_t num);

/************************************************************************************
* @brief  串口发送禁能。接口耗时：num为0耗时238.8us，num为1耗时236.7us，num为2耗时6.6us，num为3耗时6.6us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @return NA
************************************************************************************/
void McuUartTxDis(uint8_t num);

/************************************************************************************
* @brief  写入串口一字节数据。接口耗时：num为0耗时9.8us，num为1耗时7.7us，num为2耗时8.8us，num为3耗时8.8us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @param  in_byte：要发送的1字节数据
* @return 0：成功。-1：失败
************************************************************************************/
int8_t McuUartWrite(uint8_t num, uint8_t in_byte);

/************************************************************************************
* @brief  串口发送总线忙查询。接口耗时：num为0耗时9.6us，num为1耗时7.5us，num为2耗时8.8us，num为3耗时8.8us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @return 0：空闲  1：忙
************************************************************************************/
int8_t McuUartTxBusy(uint8_t num);

/************************************************************************************
* @brief  串口写指定长度数据。以115200bps为例，接口耗时如下，其中n为字节长度。
* num为0耗时45+95*(n-1)us，num为1耗时35+95*(n-1)us，
* num为2耗时115+85*(n-1)us， num为3耗时115+85*(n-1)us，
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART     
* @param  buff：要发送数据的地址
* @param  length：要发送的数据长度
* @return 0：成功。-1：失败
************************************************************************************/
int8_t McuUartWriteFram(uint8_t num, uint8_t *buff, uint16_t length);

/************************************************************************************
* @brief  读取串口的一字节数据。接口耗时：num为0耗时5.4us，num为1耗时5.6us，num为2耗时5.6us，num为3耗时5.6us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @param  out_byte：输出数据
* @return 0：无数据。1：有数据
************************************************************************************/
uint8_t McuUartRead(uint8_t num, uint8_t *out_byte);

/************************************************************************************
* @brief  串口接收中断函数注册。接口耗时：num为0耗时43.6us，num为1耗时31us，num为2耗时28.4us，num为3耗时28.7us
* @param  num：串口号，可选0-3;0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @param  p_fun：串口接收回调函数
* @return NA
************************************************************************************/
void McuUartRxIrqReg(uint8_t num, pFunType_u8 p_fun);

/************************************************************************************
* @brief  串口发送中断函数注册。接口耗时：num为0耗时19.4us，num为1耗时18us，num为2耗时18.4us，num为3耗时18.8us
* @param  num：串口号，可选0-3. 0：LPUART;1:UART;2:CSP2_UART;3:CSP3_UART
* @param  p_fun：串口发送回调函数
* @return NA
************************************************************************************/
void McuUartTxIrqReg(uint8_t num, pFunType_void p_fun);

/************************************************************************************
 * @brief 判断串口接收fifo是否空
 * @param num 串口号，可选0-3；0:LPUART、1:UART、2:CSP2_UART、3:CSP3_UART
 * @return 0:接收fifo不空(即接收未完成)
 *         1:接收fifo空(即接收完成)
 *        -1:入参错误
************************************************************************************/
int8_t McuIsUartRxfifoEmpty(uint8_t num);

/************************************************************************************
 * @brief 判断串口发送fifo是否空
 * @param num 串口号，可选0-3；0:LPUART、1:UART、2:CSP2_UART、3:CSP3_UART
 * @return 0:发送fifo不空(即发送未完成)
 *         1:发送fifo空(即发送完成)
 *        -1:入参错误
************************************************************************************/
int8_t McuIsUartTxfifoEmpty(uint8_t num);

//=====================================================================================
//================================SPI==================================================
//=====================================================================================
/*******************************warning！SPI使用注意事项***********************************
	num值为1表示SPI硬件实现SPI功能，其优点为耗时相比CSP_SPI要小，其缺点为受起CP核影响工作主频。

    num值为0表示使用CSP1实现SPI功能，其优点为不受起CP核影响工作主频，其缺点为耗时比SPI硬件大。
    CSP1外设pclk典型值为26MHz，作为SPI使用时，具有以下特性：
    (1)模拟为SPI主机时，SPI速率入参不得超过pclk的1/2
    (2)模拟为SPI从机时，SPI速率入参不得超过pclk的1/16

    此外当CSP模拟为SPI从机时，SPI从机对主机片选信号（CS#）有如下要求：
    当SPI主机发送完一字节数据后，主机必须拉高拉低一次片选信号（CS#），才可以继续给从机发送数据。
    如果SPI主机在发送过程中片选信号一直保持拉低，则SPI从机的数据发送和接收均会失败。
**************************************************************************************/
/************************************************************************************
* @brief  SPI主机选用的端口配置。接口耗时：num为0耗时：1.2623ms,num为1耗时：1.1958ms
* @param  num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @param  freq：频率，单位KHZ
                num为0时可选：100,500,1000,2000,4000,6000
                num为1时可选：360,720,1440,2880,5760
* @param  mode ：SPI工作模式，可选0,1,2,3
* @return  0：成功。 -1：失败，非法参数
************************************************************************************/
int8_t McuSpiMasterSet(uint8_t num, uint32_t freq, uint32_t mode);

/************************************************************************************
* @brief  带引脚配置的SPI主机设置。接口耗时：num为0耗时：1.2623ms,num为1耗时：1.1958ms
* @param  num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @param  freq：频率，单位KHZ
                num为0时可选：100,500,1000,2000,4000,6000
                num为1时可选：360,720,1440,2880,5760
* @param  mode      ：SPI工作模式，可选0,1,2,3
* @param  clk_pin   ：SPI主机时钟线
* @param  cs_pin    ：SPI主机片选线，MasterSet后为默认为高电平，数据收发过程中需拉低，收发完毕需拉高。
*                     该引脚除了可选普通MCU_GPIOx外，还可以选择深睡保持引脚，如MCU_WKP1~3，MCU_GPIO0~7。
* @param  mosi_pin  ：SPI主机数据输出线
* @param  miso_pin  ：SPI主机数据输入线
* @return  0：成功。 -1：失败，非法参数
************************************************************************************/
int8_t McuSpiMasterSet2(uint8_t num, uint32_t freq, uint32_t mode, uint8_t clk_pin, uint8_t cs_pin, uint8_t mosi_pin, uint8_t miso_pin);

/************************************************************************************
* @brief   SPI使能。接口耗时：num为0耗时：22.7us,num为1耗时：29.9us
* @param   num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @return   NA
************************************************************************************/
void McuSpiEn(uint8_t num);

/************************************************************************************
* @brief   SPI禁能。接口耗时：num为0耗时：22.5us,num为1耗时：17.2us
* @param   num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @return   NA
************************************************************************************/
void McuSpiDis(uint8_t num);

/************************************************************************************
* @brief   CS片选拉低 接口耗时：18us
* @param   num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @return   NA
************************************************************************************/
void McuSpiCsReset(uint8_t num);

/************************************************************************************
* @brief   CS片选拉高 接口耗时：18us
* @param   num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @return   NA
************************************************************************************/
void McuSpiCsSet(uint8_t num);

/************************************************************************************
* @brief  SPI主机写指定长度数据。接口耗时，以写10字节测试，num为0耗时：136.4us,num为1耗时：849.8us
* @param  num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @param  cmd：要发送数据的地址
* @param  len：要发送的数据长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuSpiMasterWrite(uint8_t num, uint8_t *cmd, uint16_t len);

/************************************************************************************
* @brief  SPI主机接收指定长度数据
* @param  num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @param  rec：接收数据
* @param  len：接收长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuSpiMasterRead(uint8_t num, uint8_t *rec, uint16_t len);

/************************************************************************************
* @brief  SPI主机各发送接收指定长度数据。接口耗时，以写10字节数据测试，num为0时耗时252.9us,当num为1时耗时：939.2us
* @param  num：spi底层硬件类型号，0:CSP1_SPI,1:SPI
* @param  rec：接收数据
* @param  len：接收长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuSpiMasterWriteRead(uint8_t num, uint8_t *cmd, uint8_t *rec, uint16_t len);

//=====================================================================================
//================================I2C==================================================
//=====================================================================================
/************************************************************************************
* @brief  I2C选用的端口配置。代码段位于RAM的接口耗时：num为0耗时683.8us，num为1耗时666.5us
* 代码段位于FLASH的接口耗时：num为0耗时1496.9us，num为1耗时944.5us
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @param  freq：频率，单位KHZ，可选100、400
* @return  0：成功。 -1：失败，非法参数
************************************************************************************/
int8_t McuI2cMasterSet(uint8_t num, uint32_t freq);

/************************************************************************************
* @brief  带引脚配置的I2C主机设置。代码段位于RAM的接口耗时：num为0耗时683.8us，num为1耗时666.5us
*                                代码段位于FLASH的接口耗时：num为0耗时1496.9us，num为1耗时944.5us
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @param  freq：频率，单位KHZ，可选100、400
* @param  scl_pin  ：  I2C主机时钟线
* @param  sda_pin  ：  I2C主机数据线
* @return  0：成功。 -1：失败，非法参数
************************************************************************************/
int8_t McuI2cMasterSet2(uint8_t num, uint32_t freq, uint8_t scl_pin, uint8_t sda_pin);

/************************************************************************************
* @brief  I2C去初始化。
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @return  0：成功。-1：失败，非法参数
************************************************************************************/
int8_t McuI2cDis(uint8_t num);

/************************************************************************************
* @brief  I2C主机写。接口内直接操作寄存器，耗时与外接i2c设备类型有关，时长不确定。
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @param  device_addr: 器件地址
* @param  addr_cnt   : 数据地址个数，如：24C16为1个，24C512为2个
* @param  addr       : 数据地址
* @param  pdata      : 待写数据缓冲首地址
* @param  len        : 长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuI2cMasterWrite(uint8_t num, uint8_t device_addr, uint8_t addr_cnt, uint32_t addr, const uint8_t *pdata, uint16_t len, uint32_t Timeout);

/************************************************************************************
* @brief  I2C主机读。接口内直接操作寄存器，耗时与外接i2c设备类型有关，时长不确定。
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @param  device_addr: 器件地址
* @param  addr_cnt   : 数据地址个数，如：24C16为1个，24C512为2个
* @param  addr       : 数据地址
* @param  pdata      : 待写数据缓冲首地址
* @param  len        : 长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuI2cMasterRead(uint8_t num, uint8_t device_addr, uint8_t addr_cnt, uint32_t addr, uint8_t *pdata, uint16_t len, uint32_t Timeout);

/************************************************************************************
* @brief  I2C主机直写。接口内直接操作寄存器，耗时与外接i2c设备类型有关，时长不确定。
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @param  device_addr: 器件地址
* @param  pdata      : 待写数据缓冲首地址
* @param  len        : 长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuI2cMasterDirectWrite(uint8_t num, uint8_t device_addr, const uint8_t *pdata, uint16_t len, uint32_t Timeout);

/************************************************************************************
* @brief  I2C主机直读。接口内直接操作寄存器，耗时与外接i2c设备类型有关，时长不确定。
* @param  num：i2c硬件端口号，可选0-1，分别对应I2C1/I2C2
* @param  device_addr: 器件地址
* @param  pdata      : 待写数据缓冲首地址
* @param  len        : 长度
* @return  0：成功。-1：失败
************************************************************************************/
int8_t McuI2cMasterDirectRead(uint8_t num, uint8_t device_addr, uint8_t *pdata, uint16_t len, uint32_t Timeout);

//=====================================================================================
//==============LPTIMER，建议产品秒级周期心跳时钟使用==================================
//=====================================================================================
/************************************************************************************
* @brief  lptimer1周期配置。接口耗时1218.3us
* @param  timeout_ms ：超时时长，单位ms，由于LPTIMER特性（16位计数，参考时钟32K，最大分频128），最长超时时长约为256000ms
* @return 0：成功。 -1：失败，非法参数
* @warning  xy_timer.h中实现了clocktick硬定时，通过软件方式支持多事件，可用于实时性要求不高的定时器
************************************************************************************/
int8_t McuLptimerSetPeriod(uint32_t timeout_ms);

/************************************************************************************
* @brief  lptimer2周期配置。接口耗时1218.3us
* @param  timeout_ms ：周期时间，单位：ms
* @return 0：成功。 -1：失败，非法参数
************************************************************************************/
int8_t McuLptimer2SetPeriod(uint32_t timeout_ms);

/***********************************************************************************
* @brief  获取lptimer1对应的ms数。接口耗时：us
* @param  NA
* @return  lptimer对应的ms数
***********************************************************************************/
uint32_t McuLptimerGetCountMs();

/***********************************************************************************
* @brief  获取lptimer2对应的ms数。接口耗时：us
* @param  NA
* @return  lptimer2对应的ms数
***********************************************************************************/
uint32_t McuLptimer2GetCountMs();

/************************************************************************************
* @brief   lptimer1使能。接口耗时6.1us
* @param   NA
* @return  NA
************************************************************************************/
void McuLptimerEn(void);

/************************************************************************************
* @brief   lptimer2使能。接口耗时6.1us
* @param   NA
* @return  NA
************************************************************************************/
void McuLptimer2En(void);

/************************************************************************************
* @brief   lptimer1禁能。接口耗时6.3us
* @param   NA
* @return  NA
************************************************************************************/
void McuLptimerDis(void);

/************************************************************************************
* @brief   lptimer2禁能。接口耗时6.3us
* @param   NA
* @return  NA
************************************************************************************/
void McuLptimer2Dis(void);

/************************************************************************************
* @brief  lptimer1中断函数注册。接口耗时11.4us
* @param  p_fun：中断回调函数
* @return  NA
************************************************************************************/
void McuLptimerIrqReg(pFunType_void p_fun);

/************************************************************************************
* @brief  lptimer2中断函数注册。接口耗时11.4us
* @param  p_fun：中断回调函数
* @return  NA
************************************************************************************/
void McuLptimer2IrqReg(pFunType_void p_fun);

//=====================================================================================
//================================TIMER1/TIMER2========================================
//=====================================================================================
/************************************************************************************
* @brief  timer中断函数注册。接口耗时11.4us
* @param  p_fun：中断回调函数
* @return  NA
************************************************************************************/
void McuTimerIrqReg(uint8_t num, pFunType_void p_fun);

/***********************************************************************************
* @brief  timer周期配置。接口耗时：num为1耗时230.5us，num为2耗时211.5us
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @param  timeout_ms ：周期时间，单位：ms
* @return 0：成功；-1：失败，非法参数
***********************************************************************************/
int8_t McuTimerSetPeriod(uint8_t num, uint32_t timeout_ms);

/***********************************************************************************
* @brief  获取timer对应的us数。接口耗时：num为1耗时us，num为2耗时us
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @return  timer对应的us数
***********************************************************************************/
uint32_t McuTimerGetCountUs(uint8_t num);

/***********************************************************************************
* @brief  timer周期配置。
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @param  pwmperiod_ms ：PWM周期，单位：ms
* @param  pwmduty：pwm波占空比,取值0-100
* @param  pwmgpio：pwm波输出引脚,取值（0-63）
* @return 0：成功；-1：失败，非法参数
***********************************************************************************/
__FLASH_FUNC int8_t McuTimerSetPWM2(uint8_t num, uint32_t pwmperiod_ms, uint8_t pwmduty, MCU_GPIO_PinTypeDef pwmgpio);

/***********************************************************************************
* @brief  带引脚配置的的PWM配置
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @param  pwmclk ：PWM频率，单位：Hz
* @param  pwmduty：pwm波占空比,取值0-100
* @param  pwmgpio：pwm波输出引脚,取值（0-63）
* @return 0：成功；-1：失败，非法参数
***********************************************************************************/
int8_t McuTimerSetPWM3(uint8_t num, uint32_t pwmclk, uint8_t pwmduty, MCU_GPIO_PinTypeDef pwmgpio);

/***********************************************************************************
* @brief  PWM配置
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @param  pwmclk ：PWM频率，单位：Hz
* @param  pwmduty：pwm波占空比,取值0-100
* @return 0：成功；-1：失败，非法参数
***********************************************************************************/
int8_t McuTimerSetPWM(uint8_t num, uint32_t pwmclk, uint8_t pwmduty);

/***********************************************************************************
* @brief  PWM占空比配置
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @param  pwmduty：pwm波占空比,取值0-100
* @return 无
***********************************************************************************/
void McuTimerSetPWMCMP(uint8_t num, uint8_t pwmduty);

/***********************************************************************************
* @brief  timer使能。接口耗时：num为1耗时4.8us，num为2耗时6.6us
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @return  NA
***********************************************************************************/
void McuTimerEn(uint8_t num);

/***********************************************************************************
* @brief  timer禁能。接口耗时：num为1耗时4.8us，num为2耗时6.6us
* @param  num ：timer硬件号，可选1-2，分别对应TIMER1/TIMER2
* @return  NA
***********************************************************************************/
void McuTimerDis(uint8_t num);

//=====================================================================================
//================================LCD==================================================
//=====================================================================================
typedef enum{
    XY_IO_COM0=0, XY_IO_COM1, XY_IO_COM2, XY_IO_COM3,
	XY_IO_COM4,   XY_IO_COM5, XY_IO_COM6, XY_IO_COM7
}MCU_GPIO_XY_COM;

typedef enum{
    XY_IO_SEG0=0,XY_IO_SEG1,  XY_IO_SEG2,  XY_IO_SEG3,  XY_IO_SEG4,  XY_IO_SEG5,  XY_IO_SEG6,  XY_IO_SEG7,
	XY_IO_SEG8,  XY_IO_SEG9,  XY_IO_SEG10, XY_IO_SEG11, XY_IO_SEG12, XY_IO_SEG13, XY_IO_SEG14, XY_IO_SEG15,
	XY_IO_SEG16, XY_IO_SEG17, XY_IO_SEG18, XY_IO_SEG19, XY_IO_SEG20, XY_IO_SEG21, XY_IO_SEG22, XY_IO_SEG23,
	XY_IO_SEG24, XY_IO_SEG25, XY_IO_SEG26, XY_IO_SEG27, XY_IO_SEG28, XY_IO_SEG29, XY_IO_SEG30, XY_IO_SEG31
}MCU_GPIO_XY_SEG;

typedef enum
{
    IOEQ1P8V_VLCDLT3V = 0, // 芯片IO电平为1.8V，且LCD屏幕驱动电压小于3V
    IOEQ1P8V_VLCDGT3V = 0, // 芯片IO电平为1.8V，且LCD屏幕驱动电压大于3V
    IOEQ3V_VLCDLT3V = 1,   // 芯片IO电平为3V，且LCD屏幕驱动电压小于3V
    IOEQ3V_VLCDGT3V = 0    // 芯片IO电平为3V，且LCD屏幕驱动电压大于3V
} McuLcdSupplySelTypedef;

/************************************************************************************************
 * @brief LCD初始化。接口耗时：197.5us
 * @param ComPad 芯翼com号，从0开始，bit0表示com0，相应bit设置1即选中该脚为com引脚
 * @param Segpad 芯翼seg号，从0开始，bit0表示seg0，相应bit设置1即选中该脚为seg引脚
 * @param LcdRate LCD屏幕刷新率，单位Hz，如35Hz，70Hz，140Hz
 * @param SupplySel 由LCD屏幕驱动电压和芯片IO电平决定该入参的值，请参考 @ref McuLcdSupplySelTypedef
*************************************************************************************************/
void McuLcdInit(uint32_t ComPad, uint32_t SegPad, uint32_t LcdRate, McuLcdSupplySelTypedef SupplySel);

/************************************************************************************************
 * @brief LCD使能。接口耗时：14.6us
 * @param none
 * @retval none
*************************************************************************************************/
void McuLcdEn(void);

/************************************************************************************************
 * @brief LCD禁能（熄屏），并将LCD功能引脚去使能为普通GPIO功能。接口耗时：50.1us
 * @warning 调用该接口后，LCD所用引脚的外部表现由GPIO寄存器决定，再次使用LCD时需要重新初始化LCD
 * @param none
 * @retval none
*************************************************************************************************/
void McuLcdDis(void);

/************************************************************************************************
 * @brief LCD显示刷新。lcd使能后的首次接口耗时：68.4us，lcd使能后非首次接口耗时：最差情况16ms
 * @param none
 * @retval none
*************************************************************************************************/
void McuLcdUpdate(void);

/************************************************************************************************
 * @brief 七段字符区，显示指定字符
 * @param SegNum ：0-34，表示com口上选中的段
 * @param Num : ASCII字符
 * @retval 0：成功；-1：失败
*************************************************************************************************/
int8_t McuLcdWriteNum(uint8_t SegIndex, uint8_t Num);

/************************************************************************************************
 * @brief 七段字符区，显示指定字符
 * @param SegNum ：0-34，表示com口上选中的段
 * @param Num : ASCII字符
 * @retval 0：成功；-1：失败
*************************************************************************************************/
int8_t McuLcdWriteChar(uint8_t SegIndex, uint8_t Num);

/************************************************************************************************
 * @brief 七段字字符区，从屏幕左侧往右侧依次显示指定字符串，最多显示8个字符。接口耗时：373.8us
 * @param str：待显示的字符串
 * @retval 0：成功；-1：失败
*************************************************************************************************/
int8_t McuLcdWriteStr(char *str);

/************************************************************************************************
 * @brief 说明区，显示指定说明符号。接口耗时：114.9us
 * @param Char : 说明区字符，按bit生效
 * @retval 0：成功；-1：失败
*************************************************************************************************/
int8_t McuLcdWriteExp(uint32_t Char);

/************************************************************************************************
 * @brief 状态区，显示指定说明符号。接口耗时：114.9us
 * @param Char : 状态区字符，按bit生效
 * @retval 0：成功；-1：失败
*************************************************************************************************/
int8_t McuLcdWriteStatus(uint32_t Char);

/************************************************************************************************
 * @brief 状态区，显示指定说明符号。
 * @param bit_value : 状态区字符对应的bit位，flag：1显示；0不显示
 * @retval 0：成功；-1：失败
*************************************************************************************************/
int8_t McuLcdWriteOneStatus(uint32_t bit_value, uint32_t flag);

/************************************************************************************
 * @brief  清除屏幕显示
 * @param 
 * @retval 
************************************************************************************/
void McuLcdClear(void);

/************************************************************************************
 * @brief  全显
 * @param SegPad
 * @retval 
************************************************************************************/
void McuLcdDisplayAll(uint64_t SegPad);

/************************************************************************************************
 * @brief 将十进制数字转换成最大8位的ASCII码。接口耗时：79.6us
 * @param dec : 需要转换为ASCII码的十进制数
 * @param asc : 存放转换后的ASCII码，最大8位
 * @retval none
*************************************************************************************************/
void McuLcdDecToAscii(uint32_t dec, uint8_t *asc);
