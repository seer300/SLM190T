7.1方案介绍

1200S/2100S AP CP各自有一块128KB的SRAM，通用版本两块内存是隔离的，AP核仅工作在自身的128K空间中。但部分表计因为业务代码的RAM需求更大，且功耗要求很高，进而芯翼提供了动态内存复用的方案。

核心思想为：
针对SO文件夹里的代码，单AP核工作时运行在CP的SRAM上；当动态启动CP核后，切换为运行在FLASH上。
深睡期间，包括CP核的SRAM都保持供电，唤醒后AP核执行快速恢复流程，且使用大内存版本工作。

7.2特别说明

一旦加载CP后，SO文件夹中的代码运行在FLASH上，与单核场景下运行在CP RAM上性能基本接近。

该方案会保持CP SRAM供电，会增大深睡底电流。开启CP核的64K SRAM，则增大1uA；若开启128K SRAM，则增大2.8uA。考虑到该方案不再频繁使用flash，进而flash的功耗开销会很小，从而对总体功耗不会产生影响。具体参阅“内存与功耗极致优化”章节。

7.3使用注意事项

7.3.1动态加载CP核的注意事项
动态内存切换在Boot_CP()内部完成，需保证当前栈轨迹中所有用到的父函数都不能位于SO文件夹内部。否则会因为SO文件夹的动态内存复用而造成栈空间内的旧地址不可用。

7.3.2代码存放位置注意事项
不使用动态内存复用方案的客户，只需不要在SO文件夹中添加任何代码即可。

对于使用内存复用方案的客户，用户业务代码必须放在SO文件夹中实现。但中断服务函数由于不能运行在FLASH上，进而不得放在SO文件夹中。

7.3.3__RAM_FUNC与__FLASH_FUNC注意事项
SO文件夹内部，__RAM_FUNC与__FLASH_FUNC不能再使用，否则运行会出异常。请用户务必排查干净。

7.3.4__WEAK弱函数使用注意
SO文件夹内部，__WEAK编译宏无效。同时，由于SO链接的调整，造成SO文件夹内部无法重定义外部的若函数，进而会造成编译报类似错误：symbol URC_CTLWRECV_Proc appears multiple times!
解决措施就是搜索URC_CTLWRECV_Proc，将弱函数的定义用宏#if DYN_LOAD==0圈起来即可。

7.4内存与功耗极致优化
使用动态内存复用技术，进而SO文件夹中的内容不再占用AP核的128K内存空间，进而其他文件夹的内存空间就会更充裕。
我们可以尝试将非SO文件夹（MIDDLEWARE和PROJECT）中的CMakeLists.txt里通过编译宏将CONFIG_DYN_LOAD_SELECT注掉，以将所有内容运行在AP核的SRAM上。进而可以无需保持FLASH的深睡供电，改为唤醒后按需开启FLASH，能够有效降低产品平均功耗。
若因为非SO文件夹的内容过大，而造成AP核报内存不足，例如报region `RAM' overflowed by 3927512 bytes，再如xy_malloc申请失败等。则建议将部分非中断函数移到SO文件夹来解决，也可以将低频率周期运行的函数放在flash上。